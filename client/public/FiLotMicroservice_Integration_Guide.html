
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>FiLotMicroservice Client Integration Guide</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 20px;
            color: #333;
        }
        h1 { color: #1e40af; border-bottom: 3px solid #1e40af; padding-bottom: 10px; }
        h2 { color: #1e40af; border-bottom: 1px solid #e5e7eb; padding-bottom: 5px; margin-top: 30px; }
        h3 { color: #374151; margin-top: 25px; }
        code { background-color: #f3f4f6; padding: 2px 6px; border-radius: 4px; font-family: monospace; }
        pre { background-color: #f8fafc; border: 1px solid #e5e7eb; border-radius: 8px; padding: 16px; overflow-x: auto; }
        table { border-collapse: collapse; width: 100%; margin: 15px 0; }
        th, td { border: 1px solid #e5e7eb; padding: 8px 12px; text-align: left; }
        th { background-color: #f3f4f6; font-weight: 600; }
        .header { text-align: center; margin-bottom: 40px; border-bottom: 2px solid #1e40af; padding-bottom: 20px; }
        .footer { text-align: center; margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; color: #6b7280; }
    </style>
</head>
<body>
    <div class="header">
        <h1>FiLotMicroservice</h1>
        <p><strong>Client Integration Guide</strong></p>
        <p>Precision Investing API Documentation</p>
        <p>Version 1.0.0 | Production Ready</p>
    </div>
    <div>
<p><h1>FiLotMicroservice Client Integration Guide</h1></p><p><strong>Complete Developer Documentation for Precision Investing API</strong></p><p>---</p><p><h2>Quick Start</h2></p><p>FiLotMicroservice provides <strong>free</strong>, <strong>no-authentication</strong> access to authentic Raydium SDK v2 functionality for DeFi trading and precision investing.</p><p><strong>Base URL:</strong> <code>https://filotmicroservice.replit.app</code></p><p><strong>API Version:</strong> 1.0.0</p><p><strong>Authentication:</strong> None required</p><p>---</p><p><h2>Table of Contents</h2></p><p>1. <a href="#api-overview">API Overview</a><br>2. <a href="#rate-limits--usage-guidelines">Rate Limits & Usage Guidelines</a><br>3. <a href="#response-format">Response Format</a><br>4. <a href="#error-handling">Error Handling</a><br>5. <a href="#complete-endpoint-reference">Complete Endpoint Reference</a><br>6. <a href="#integration-examples">Integration Examples</a><br>7. <a href="#sdk-implementations">SDK Implementations</a><br>8. <a href="#testing--validation">Testing & Validation</a><br>9. <a href="#production-best-practices">Production Best Practices</a><br>10. <a href="#troubleshooting">Troubleshooting</a></p><p>---</p><p><h2>API Overview</h2></p><p><h3>Features</h3><br>- <strong>Authentic Raydium SDK v2 Integration</strong> - Real-time DeFi data<br>- <strong>Zero Configuration</strong> - No API keys or registration required<br>- <strong>High Performance</strong> - Average response time: 40ms<br>- <strong>100% Uptime</strong> - Reliable service with comprehensive monitoring<br>- <strong>Real-time Data</strong> - Live pools, tokens, and swap calculations<br>- <strong>Multiple Formats</strong> - JSON responses with consistent structure</p><p><h3>Supported Operations</h3><br>- Health monitoring and API status<br>- Liquidity pool data retrieval<br>- Token information and metadata<br>- Swap quote calculations<br>- Token account parsing<br>- Performance metrics access</p><p>---</p><p><h2>Rate Limits & Usage Guidelines</h2></p><p><h3>Current Limits</h3><br>- <strong>No rate limits</strong> currently enforced<br>- <strong>Fair usage policy</strong> applies<br>- <strong>Respectful crawling</strong> recommended (1-second delay between requests)</p><p><h3>Recommended Usage Patterns</h3><br><pre><code>bash<br><h1>Good: Sequential requests with delay</h1><br>curl https://filotmicroservice.replit.app/api/health<br>sleep 1<br>curl https://filotmicroservice.replit.app/api/pools</p><p><h1>Avoid: Rapid burst requests</h1><br></code></pre></p><p>---</p><p><h2>Response Format</h2></p><p><h3>Standard Response Structure</h3><br>All endpoints return JSON with consistent structure:</p><p><pre><code>json<br>{<br>  "data": {...},           // Main response data<br>  "count": 123,           // Count for collection endpoints<br>  "updated": "ISO8601",   // Last update timestamp<br>  "status": "success"     // Operation status<br>}<br></code></pre></p><p><h3>Error Response Structure</h3><br><pre><code>json<br>{<br>  "error": "Error description",<br>  "statusCode": 400,<br>  "timestamp": "2025-05-24T03:57:20.123Z",<br>  "path": "/api/endpoint"<br>}<br></code></pre></p><p>---</p><p><h2>Error Handling</h2></p><p><h3>HTTP Status Codes</h3><br>| Code | Meaning | Action Required |<br>|------|---------|----------------|<br>| <code>200</code> | Success | Continue processing |<br>| <code>400</code> | Bad Request | Check request parameters |<br>| <code>404</code> | Not Found | Verify resource exists |<br>| <code>500</code> | Server Error | Retry after delay |</p><p><h3>Error Handling Examples</h3></p><p>#### JavaScript/TypeScript<br><pre><code>javascript<br>async function fetchWithErrorHandling(url) {<br>  try {<br>    const response = await fetch(url);<br>    <br>    if (!response.ok) {<br>      const errorData = await response.json();<br>      throw new Error(<code>API Error: ${errorData.error} (${response.status})</code>);<br>    }<br>    <br>    return await response.json();<br>  } catch (error) {<br>    console.error('API request failed:', error.message);<br>    <br>    // Implement retry logic<br>    if (error.message.includes('500')) {<br>      console.log('Retrying in 5 seconds...');<br>      await new Promise(resolve => setTimeout(resolve, 5000));<br>      return fetchWithErrorHandling(url); // Retry once<br>    }<br>    <br>    throw error;<br>  }<br>}<br></code></pre></p><p>#### Python<br><pre><code>python<br>import requests<br>import time<br>from typing import Dict, Any</p><p>def api_request_with_retry(url: str, max_retries: int = 3) -> Dict[Any, Any]:<br>    for attempt in range(max_retries):<br>        try:<br>            response = requests.get(url, timeout=30)<br>            response.raise_for_status()<br>            return response.json()<br>            <br>        except requests.exceptions.HTTPError as e:<br>            if e.response.status_code == 500 and attempt < max_retries - 1:<br>                wait_time = 2 <strong> attempt  # Exponential backoff<br>                print(f"Server error, retrying in {wait_time} seconds...")<br>                time.sleep(wait_time)<br>                continue<br>            raise<br>            <br>        except requests.exceptions.RequestException as e:<br>            print(f"Request failed: {e}")<br>            if attempt < max_retries - 1:<br>                time.sleep(2 </strong> attempt)<br>                continue<br>            raise<br>    <br>    raise Exception("Max retries exceeded")<br></code></pre></p><p>---</p><p><h2>Complete Endpoint Reference</h2></p><p><h3>1. Health Check</h3><br>Monitor API status and connection to Raydium SDK.</p><p><strong>Endpoint:</strong> <code>GET /api/health</code></p><p><strong>Response:</strong><br><pre><code>json<br>{<br>  "status": "healthy",<br>  "timestamp": "2025-05-24T03:57:20.123Z",<br>  "version": "1.0.0",<br>  "raydium": "connected",<br>  "metrics": {<br>    "totalRequests": 1250,<br>    "averageResponseTime": 42.3,<br>    "errorRate": 0.0,<br>    "uptime": 100<br>  }<br>}<br></code></pre></p><p><strong>Integration Example:</strong><br><pre><code>javascript<br>// Health check with monitoring<br>async function checkApiHealth() {<br>  const health = await fetch('https://filotmicroservice.replit.app/api/health')<br>    .then(res => res.json());<br>  <br>  console.log(<code>API Status: ${health.status}</code>);<br>  console.log(<code>Raydium Connection: ${health.raydium}</code>);<br>  console.log(<code>Uptime: ${health.metrics.uptime}%</code>);<br>  <br>  return health.status === 'healthy' && health.raydium === 'connected';<br>}<br></code></pre></p><p><h3>2. Liquidity Pools</h3><br>Retrieve authentic Raydium liquidity pool data.</p><p><strong>Endpoint:</strong> <code>GET /api/pools</code></p><p><strong>Response:</strong><br><pre><code>json<br>{<br>  "pools": [<br>    {<br>      "id": 1,<br>      "poolId": "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2",<br>      "baseTokenMint": "So11111111111111111111111111111111111111112",<br>      "quoteTokenMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",<br>      "lpTokenMint": "8HoQnePLqPj4M7PUDzfw8e3Ymdwgc7NLGnaTUapubyvu",<br>      "baseTokenReserve": "2547891234567890",<br>      "quoteTokenReserve": "458932145678901",<br>      "tvl": 1250000.50,<br>      "volume24h": 850000.25,<br>      "apy": 125.75,<br>      "createdAt": "2025-05-24T03:57:20.123Z",<br>      "updatedAt": "2025-05-24T03:57:20.123Z"<br>    }<br>  ],<br>  "count": 1,<br>  "updated": "2025-05-24T03:57:20.123Z"<br>}<br></code></pre></p><p><strong>Integration Example:</strong><br><pre><code>python<br><h1>Filter high-value pools</h1><br>import requests</p><p>def get_high_tvl_pools(min_tvl: float = 1000000) -> list:<br>    response = requests.get('https://filotmicroservice.replit.app/api/pools')<br>    data = response.json()<br>    <br>    high_tvl_pools = [<br>        pool for pool in data['pools'] <br>        if pool['tvl'] and pool['tvl'] >= min_tvl<br>    ]<br>    <br>    # Sort by TVL descending<br>    high_tvl_pools.sort(key=lambda x: x['tvl'], reverse=True)<br>    <br>    print(f"Found {len(high_tvl_pools)} pools with TVL >= ${min_tvl:,.2f}")<br>    return high_tvl_pools</p><p><h1>Usage</h1><br>top_pools = get_high_tvl_pools(500000)  # Pools with $500k+ TVL<br>for pool in top_pools[:5]:  # Top 5<br>    print(f"Pool: {pool['poolId']} - TVL: ${pool['tvl']:,.2f}")<br></code></pre></p><p><h3>3. Specific Pool</h3><br>Get detailed information for a specific pool.</p><p><strong>Endpoint:</strong> <code>GET /api/pools/{poolId}</code></p><p><strong>Parameters:</strong><br>- <code>poolId</code> (string): The unique pool identifier</p><p><strong>Example:</strong><br><pre><code>bash<br>curl https://filotmicroservice.replit.app/api/pools/58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2<br></code></pre></p><p><h3>4. Token Information</h3><br>Retrieve authentic token metadata and pricing.</p><p><strong>Endpoint:</strong> <code>GET /api/tokens</code></p><p><strong>Response:</strong><br><pre><code>json<br>{<br>  "tokens": [<br>    {<br>      "id": 1,<br>      "symbol": "SOL",<br>      "name": "Solana",<br>      "mint": "So11111111111111111111111111111111111111112",<br>      "decimals": 9,<br>      "logoUri": "https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",<br>      "price": 185.45,<br>      "volume24h": 45000000.00,<br>      "marketCap": 85000000000.00,<br>      "createdAt": "2025-05-24T03:57:20.123Z",<br>      "updatedAt": "2025-05-24T03:57:20.123Z"<br>    }<br>  ],<br>  "count": 1,<br>  "updated": "2025-05-24T03:57:20.123Z"<br>}<br></code></pre></p><p><strong>Integration Example:</strong><br><pre><code>javascript<br>// Token price monitoring<br>class TokenPriceMonitor {<br>  constructor() {<br>    this.baseUrl = 'https://filotmicroservice.replit.app';<br>    this.watchlist = [];<br>    this.priceAlerts = new Map();<br>  }<br>  <br>  async addToWatchlist(tokenMint, alertPrice = null) {<br>    try {<br>      const response = await fetch(<code>${this.baseUrl}/api/tokens/${tokenMint}</code>);<br>      <br>      if (response.ok) {<br>        const token = await response.json();<br>        this.watchlist.push(token);<br>        <br>        if (alertPrice) {<br>          this.priceAlerts.set(tokenMint, alertPrice);<br>        }<br>        <br>        console.log(<code>Added ${token.symbol} to watchlist</code>);<br>        return token;<br>      } else {<br>        console.error(<code>Token not found: ${tokenMint}</code>);<br>        return null;<br>      }<br>    } catch (error) {<br>      console.error('Failed to add token to watchlist:', error);<br>      return null;<br>    }<br>  }<br>  <br>  async checkPriceAlerts() {<br>    const tokens = await fetch(<code>${this.baseUrl}/api/tokens</code>)<br>      .then(res => res.json());<br>    <br>    for (const token of tokens.tokens) {<br>      const alertPrice = this.priceAlerts.get(token.mint);<br>      <br>      if (alertPrice && token.price >= alertPrice) {<br>        this.triggerAlert(token, alertPrice);<br>      }<br>    }<br>  }<br>  <br>  triggerAlert(token, targetPrice) {<br>    console.log(<code>PRICE ALERT: ${token.symbol} reached $${token.price} (target: $${targetPrice})</code>);<br>    // Implement notification logic (email, webhook, etc.)<br>  }<br>}</p><p>// Usage<br>const monitor = new TokenPriceMonitor();<br>await monitor.addToWatchlist('So11111111111111111111111111111111111111112', 200); // SOL at $200<br></code></pre></p><p><h3>5. Swap Quote Calculation</h3><br>Calculate authentic swap quotes using Raydium SDK.</p><p><strong>Endpoint:</strong> <code>POST /api/swap/quote</code></p><p><strong>Request Body:</strong><br><pre><code>json<br>{<br>  "inputMint": "So11111111111111111111111111111111111111112",<br>  "outputMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",<br>  "amount": "1000000000",<br>  "slippage": 0.5<br>}<br></code></pre></p><p><strong>Response:</strong><br><pre><code>json<br>{<br>  "inputMint": "So11111111111111111111111111111111111111112",<br>  "outputMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",<br>  "inputAmount": "1000000000",<br>  "outputAmount": "185450000",<br>  "priceImpact": "0.12",<br>  "slippage": 0.5,<br>  "route": ["Raydium AMM"],<br>  "minOutputAmount": "184525250"<br>}<br></code></pre></p><p><strong>Integration Examples:</strong></p><p>#### Advanced Swap Calculator<br><pre><code>javascript<br>class SwapCalculator {<br>  constructor() {<br>    this.baseUrl = 'https://filotmicroservice.replit.app';<br>  }<br>  <br>  async calculateSwap(inputMint, outputMint, amount, slippage = 0.5) {<br>    const requestBody = {<br>      inputMint,<br>      outputMint,<br>      amount: amount.toString(),<br>      slippage<br>    };<br>    <br>    try {<br>      const response = await fetch(<code>${this.baseUrl}/api/swap/quote</code>, {<br>        method: 'POST',<br>        headers: {<br>          'Content-Type': 'application/json',<br>        },<br>        body: JSON.stringify(requestBody)<br>      });<br>      <br>      if (!response.ok) {<br>        throw new Error(<code>HTTP ${response.status}: ${await response.text()}</code>);<br>      }<br>      <br>      const quote = await response.json();<br>      <br>      return {<br>        ...quote,<br>        pricePerUnit: parseFloat(quote.outputAmount) / parseFloat(quote.inputAmount),<br>        effectivePrice: this.calculateEffectivePrice(quote),<br>        recommendedSlippage: this.recommendSlippage(quote.priceImpact)<br>      };<br>    } catch (error) {<br>      console.error('Swap calculation failed:', error);<br>      throw error;<br>    }<br>  }<br>  <br>  calculateEffectivePrice(quote) {<br>    const input = parseFloat(quote.inputAmount);<br>    const output = parseFloat(quote.outputAmount);<br>    return output / input;<br>  }<br>  <br>  recommendSlippage(priceImpact) {<br>    const impact = parseFloat(priceImpact);<br>    <br>    if (impact < 0.1) return 0.5;<br>    if (impact < 0.5) return 1.0;<br>    if (impact < 1.0) return 2.0;<br>    return 5.0; // High impact trades<br>  }<br>  <br>  async findBestRate(inputMint, amount, outputMints) {<br>    const quotes = await Promise.all(<br>      outputMints.map(async (outputMint) => {<br>        try {<br>          const quote = await this.calculateSwap(inputMint, outputMint, amount);<br>          return { outputMint, quote };<br>        } catch {<br>          return { outputMint, quote: null };<br>        }<br>      })<br>    );<br>    <br>    return quotes<br>      .filter(q => q.quote !== null)<br>      .sort((a, b) => parseFloat(b.quote.outputAmount) - parseFloat(a.quote.outputAmount));<br>  }<br>}</p><p>// Usage Examples<br>const calculator = new SwapCalculator();</p><p>// Single swap quote<br>const quote = await calculator.calculateSwap(<br>  'So11111111111111111111111111111111111111112',  // SOL<br>  'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',  // USDC<br>  1000000000  // 1 SOL<br>);</p><p>console.log(<code>1 SOL = ${quote.pricePerUnit} USDC</code>);<br>console.log(<code>Price Impact: ${quote.priceImpact}%</code>);<br>console.log(<code>Recommended Slippage: ${quote.recommendedSlippage}%</code>);</p><p>// Compare rates across multiple tokens<br>const stablecoins = [<br>  'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',  // USDC<br>  'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB',  // USDT<br>];</p><p>const bestRates = await calculator.findBestRate(<br>  'So11111111111111111111111111111111111111112',  // SOL<br>  1000000000,  // 1 SOL<br>  stablecoins<br>);</p><p>console.log('Best rates for 1 SOL:');<br>bestRates.forEach(({ outputMint, quote }, index) => {<br>  console.log(<code>${index + 1}. ${quote.outputAmount} (${outputMint.slice(0, 8)}...)</code>);<br>});<br></code></pre></p><p><h3>6. Token Account Parsing</h3><br>Parse authentic token account data from Solana blockchain.</p><p><strong>Endpoint:</strong> <code>POST /api/token-account/parse</code></p><p><strong>Request Body:</strong><br><pre><code>json<br>{<br>  "accountData": "base64_encoded_account_data",<br>  "owner": "owner_public_key"<br>}<br></code></pre></p><p><strong>Response:</strong><br><pre><code>json<br>{<br>  "mint": "Giajs249VSiuF3Ui5CKyKSxLTtUa6rFAxw5ZZ7dspump",<br>  "owner": "11111111111111111111111111111112",<br>  "amount": "17448792100",<br>  "decimals": 9,<br>  "uiAmount": 17.4487921,<br>  "uiAmountString": "17.4487921"<br>}<br></code></pre></p><p><h3>7. API Metrics</h3><br>Access performance metrics and recent request logs.</p><p><strong>Endpoint:</strong> <code>GET /api/metrics</code></p><p><strong>Response:</strong><br><pre><code>json<br>{<br>  "totalRequests": 1850,<br>  "averageResponseTime": 38.5,<br>  "errorRate": 0.0,<br>  "uptime": 100,<br>  "recentRequests": [<br>    {<br>      "endpoint": "/api/swap/quote",<br>      "method": "POST",<br>      "responseTime": 149,<br>      "statusCode": 200,<br>      "timestamp": "2025-05-24T03:57:20.123Z"<br>    }<br>  ]<br>}<br></code></pre></p><p>---</p><p><h2>Integration Examples</h2></p><p><h3>React/Next.js Integration</h3></p><p><pre><code>jsx<br>// hooks/useFilotApi.js<br>import { useState, useEffect } from 'react';</p><p>const BASE_URL = 'https://filotmicroservice.replit.app';</p><p>export function useApiHealth() {<br>  const [health, setHealth] = useState(null);<br>  const [loading, setLoading] = useState(true);<br>  <br>  useEffect(() => {<br>    async function checkHealth() {<br>      try {<br>        const response = await fetch(<code>${BASE_URL}/api/health</code>);<br>        const data = await response.json();<br>        setHealth(data);<br>      } catch (error) {<br>        console.error('Health check failed:', error);<br>      } finally {<br>        setLoading(false);<br>      }<br>    }<br>    <br>    checkHealth();<br>    const interval = setInterval(checkHealth, 30000); // Check every 30s<br>    <br>    return () => clearInterval(interval);<br>  }, []);<br>  <br>  return { health, loading };<br>}</p><p>export function usePools() {<br>  const [pools, setPools] = useState([]);<br>  const [loading, setLoading] = useState(true);<br>  <br>  useEffect(() => {<br>    fetch(<code>${BASE_URL}/api/pools</code>)<br>      .then(res => res.json())<br>      .then(data => {<br>        setPools(data.pools);<br>        setLoading(false);<br>      })<br>      .catch(error => {<br>        console.error('Failed to fetch pools:', error);<br>        setLoading(false);<br>      });<br>  }, []);<br>  <br>  return { pools, loading };<br>}</p><p>export function useSwapQuote(inputMint, outputMint, amount, slippage = 0.5) {<br>  const [quote, setQuote] = useState(null);<br>  const [loading, setLoading] = useState(false);<br>  const [error, setError] = useState(null);<br>  <br>  const calculateQuote = async () => {<br>    if (!inputMint || !outputMint || !amount) return;<br>    <br>    setLoading(true);<br>    setError(null);<br>    <br>    try {<br>      const response = await fetch(<code>${BASE_URL}/api/swap/quote</code>, {<br>        method: 'POST',<br>        headers: {<br>          'Content-Type': 'application/json',<br>        },<br>        body: JSON.stringify({<br>          inputMint,<br>          outputMint,<br>          amount: amount.toString(),<br>          slippage<br>        })<br>      });<br>      <br>      if (!response.ok) {<br>        throw new Error(<code>HTTP ${response.status}</code>);<br>      }<br>      <br>      const data = await response.json();<br>      setQuote(data);<br>    } catch (err) {<br>      setError(err.message);<br>    } finally {<br>      setLoading(false);<br>    }<br>  };<br>  <br>  return { quote, loading, error, calculateQuote };<br>}</p><p>// components/SwapCalculator.jsx<br>import React, { useState } from 'react';<br>import { useSwapQuote } from '../hooks/useFilotApi';</p><p>export default function SwapCalculator() {<br>  const [inputMint, setInputMint] = useState('So11111111111111111111111111111111111111112');<br>  const [outputMint, setOutputMint] = useState('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');<br>  const [amount, setAmount] = useState('1000000000');<br>  const [slippage, setSlippage] = useState(0.5);<br>  <br>  const { quote, loading, error, calculateQuote } = useSwapQuote(<br>    inputMint, <br>    outputMint, <br>    amount, <br>    slippage<br>  );<br>  <br>  return (<br>    <div className="swap-calculator"><br>      <h2>Swap Calculator</h2><br>      <br>      <div><br>        <label>Input Token Mint:</label><br>        <input <br>          value={inputMint} <br>          onChange={(e) => setInputMint(e.target.value)}<br>          placeholder="Token mint address"<br>        /><br>      </div><br>      <br>      <div><br>        <label>Output Token Mint:</label><br>        <input <br>          value={outputMint} <br>          onChange={(e) => setOutputMint(e.target.value)}<br>          placeholder="Token mint address"<br>        /><br>      </div><br>      <br>      <div><br>        <label>Amount:</label><br>        <input <br>          value={amount} <br>          onChange={(e) => setAmount(e.target.value)}<br>          placeholder="Amount in smallest unit"<br>        /><br>      </div><br>      <br>      <div><br>        <label>Slippage (%):</label><br>        <input <br>          type="number" <br>          value={slippage} <br>          onChange={(e) => setSlippage(parseFloat(e.target.value))}<br>          step="0.1"<br>          min="0.1"<br>          max="10"<br>        /><br>      </div><br>      <br>      <button onClick={calculateQuote} disabled={loading}><br>        {loading ? 'Calculating...' : 'Get Quote'}<br>      </button><br>      <br>      {error && (<br>        <div className="error"><br>          Error: {error}<br>        </div><br>      )}<br>      <br>      {quote && (<br>        <div className="quote-result"><br>          <h3>Quote Result</h3><br>          <p>Input Amount: {quote.inputAmount}</p><br>          <p>Output Amount: {quote.outputAmount}</p><br>          <p>Price Impact: {quote.priceImpact}%</p><br>          <p>Route: {quote.route.join(' â†’ ')}</p><br>          <p>Minimum Output: {quote.minOutputAmount}</p><br>        </div><br>      )}<br>    </div><br>  );<br>}<br></code></pre></p><p><h3>Python Trading Bot Framework</h3></p><p><pre><code>python<br>import asyncio<br>import aiohttp<br>import logging<br>from dataclasses import dataclass<br>from typing import List, Optional, Dict, Any<br>from datetime import datetime, timedelta</p><p>@dataclass<br>class SwapQuote:<br>    input_mint: str<br>    output_mint: str<br>    input_amount: str<br>    output_amount: str<br>    price_impact: float<br>    slippage: float<br>    route: List[str]<br>    min_output_amount: str<br>    timestamp: datetime</p><p>class FilotApiClient:<br>    def __init__(self, base_url: str = "https://filotmicroservice.replit.app"):<br>        self.base_url = base_url<br>        self.session: Optional[aiohttp.ClientSession] = None<br>        self.logger = logging.getLogger(__name__)<br>        <br>    async def __aenter__(self):<br>        self.session = aiohttp.ClientSession(<br>            timeout=aiohttp.ClientTimeout(total=30),<br>            headers={'Content-Type': 'application/json'}<br>        )<br>        return self<br>        <br>    async def __aexit__(self, exc_type, exc_val, exc_tb):<br>        if self.session:<br>            await self.session.close()<br>    <br>    async def get_health(self) -> Dict[str, Any]:<br>        """Check API health status"""<br>        async with self.session.get(f"{self.base_url}/api/health") as response:<br>            response.raise_for_status()<br>            return await response.json()<br>    <br>    async def get_pools(self) -> List[Dict[str, Any]]:<br>        """Fetch all liquidity pools"""<br>        async with self.session.get(f"{self.base_url}/api/pools") as response:<br>            response.raise_for_status()<br>            data = await response.json()<br>            return data['pools']<br>    <br>    async def get_tokens(self) -> List[Dict[str, Any]]:<br>        """Fetch all tokens"""<br>        async with self.session.get(f"{self.base_url}/api/tokens") as response:<br>            response.raise_for_status()<br>            data = await response.json()<br>            return data['tokens']<br>    <br>    async def get_swap_quote(<br>        self, <br>        input_mint: str, <br>        output_mint: str, <br>        amount: str, <br>        slippage: float = 0.5<br>    ) -> SwapQuote:<br>        """Calculate swap quote"""<br>        payload = {<br>            "inputMint": input_mint,<br>            "outputMint": output_mint,<br>            "amount": amount,<br>            "slippage": slippage<br>        }<br>        <br>        async with self.session.post(<br>            f"{self.base_url}/api/swap/quote",<br>            json=payload<br>        ) as response:<br>            response.raise_for_status()<br>            data = await response.json()<br>            <br>            return SwapQuote(<br>                input_mint=data['inputMint'],<br>                output_mint=data['outputMint'],<br>                input_amount=data['inputAmount'],<br>                output_amount=data['outputAmount'],<br>                price_impact=float(data['priceImpact']),<br>                slippage=data['slippage'],<br>                route=data['route'],<br>                min_output_amount=data['minOutputAmount'],<br>                timestamp=datetime.now()<br>            )</p><p>class ArbitrageBot:<br>    def __init__(self, min_profit_threshold: float = 0.01):<br>        self.client = FilotApiClient()<br>        self.min_profit_threshold = min_profit_threshold<br>        self.logger = logging.getLogger(__name__)<br>        <br>    async def find_arbitrage_opportunities(<br>        self, <br>        base_token: str, <br>        quote_tokens: List[str],<br>        amount: str<br>    ) -> List[Dict[str, Any]]:<br>        """Find arbitrage opportunities across different token pairs"""<br>        opportunities = []<br>        <br>        async with self.client:<br>            # Check if API is healthy<br>            health = await self.client.get_health()<br>            if health['status'] != 'healthy':<br>                self.logger.warning("API not healthy, skipping arbitrage check")<br>                return opportunities<br>            <br>            # Get quotes for all pairs<br>            tasks = []<br>            for quote_token in quote_tokens:<br>                # Forward: base -> quote<br>                tasks.append(self.client.get_swap_quote(base_token, quote_token, amount))<br>                # Reverse: quote -> base (estimate)<br>                tasks.append(self.client.get_swap_quote(quote_token, base_token, "1000000"))<br>            <br>            try:<br>                quotes = await asyncio.gather(<em>tasks, return_exceptions=True)<br>                <br>                # Analyze for arbitrage opportunities<br>                for i in range(0, len(quotes), 2):<br>                    if isinstance(quotes[i], Exception) or isinstance(quotes[i+1], Exception):<br>                        continue<br>                        <br>                    forward_quote = quotes[i]<br>                    reverse_quote = quotes[i+1]<br>                    <br>                    # Calculate potential profit<br>                    profit_ratio = self.calculate_profit_ratio(forward_quote, reverse_quote)<br>                    <br>                    if profit_ratio > self.min_profit_threshold:<br>                        opportunities.append({<br>                            'base_token': base_token,<br>                            'quote_token': forward_quote.output_mint,<br>                            'profit_ratio': profit_ratio,<br>                            'forward_quote': forward_quote,<br>                            'reverse_quote': reverse_quote,<br>                            'timestamp': datetime.now()<br>                        })<br>                        <br>            except Exception as e:<br>                self.logger.error(f"Error finding arbitrage opportunities: {e}")<br>        <br>        return sorted(opportunities, key=lambda x: x['profit_ratio'], reverse=True)<br>    <br>    def calculate_profit_ratio(self, forward_quote: SwapQuote, reverse_quote: SwapQuote) -> float:<br>        """Calculate profit ratio for arbitrage opportunity"""<br>        try:<br>            # Simplified calculation - in practice, you'd need more complex logic<br>            forward_rate = float(forward_quote.output_amount) / float(forward_quote.input_amount)<br>            reverse_rate = float(reverse_quote.output_amount) / float(reverse_quote.input_amount)<br>            <br>            # Account for price impact and slippage<br>            adjusted_forward = forward_rate </em> (1 - forward_quote.price_impact / 100)<br>            adjusted_reverse = reverse_rate <em> (1 - reverse_quote.price_impact / 100)<br>            <br>            return (adjusted_forward </em> adjusted_reverse) - 1.0<br>        except (ValueError, ZeroDivisionError):<br>            return 0.0</p><p><h1>Usage Example</h1><br>async def main():<br>    logging.basicConfig(level=logging.INFO)<br>    <br>    bot = ArbitrageBot(min_profit_threshold=0.005)  # 0.5% minimum profit<br>    <br>    # Define tokens to monitor<br>    SOL = "So11111111111111111111111111111111111111112"<br>    stable_coins = [<br>        "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",  # USDC<br>        "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",  # USDT<br>    ]<br>    <br>    # Look for arbitrage opportunities<br>    opportunities = await bot.find_arbitrage_opportunities(<br>        base_token=SOL,<br>        quote_tokens=stable_coins,<br>        amount="1000000000"  # 1 SOL<br>    )<br>    <br>    print(f"Found {len(opportunities)} arbitrage opportunities:")<br>    for opp in opportunities:<br>        print(f"  {opp['base_token'][:8]}... â†” {opp['quote_token'][:8]}... "<br>              f"Profit: {opp['profit_ratio']:.2%}")</p><p>if __name__ == "__main__":<br>    asyncio.run(main())<br></code></pre></p><p>---</p><p><h2>ðŸ§ª Testing & Validation</h2></p><p><h3>Testing Framework</h3><br><pre><code>javascript<br>// test/filot-api.test.js<br>const assert = require('assert');<br>const fetch = require('node-fetch');</p><p>const BASE_URL = 'https://filotmicroservice.replit.app';</p><p>describe('FiLotMicroservice API Tests', () => {<br>  <br>  describe('Health Check', () => {<br>    it('should return healthy status', async () => {<br>      const response = await fetch(<code>${BASE_URL}/api/health</code>);<br>      const data = await response.json();<br>      <br>      assert.strictEqual(response.status, 200);<br>      assert.strictEqual(data.status, 'healthy');<br>      assert.strictEqual(data.raydium, 'connected');<br>      assert(data.metrics);<br>    });<br>  });<br>  <br>  describe('Pools Endpoint', () => {<br>    it('should return pools data', async () => {<br>      const response = await fetch(<code>${BASE_URL}/api/pools</code>);<br>      const data = await response.json();<br>      <br>      assert.strictEqual(response.status, 200);<br>      assert(Array.isArray(data.pools));<br>      assert(typeof data.count === 'number');<br>      assert(data.updated);<br>    });<br>  });<br>  <br>  describe('Swap Quote', () => {<br>    it('should calculate swap quote for valid pairs', async () => {<br>      const payload = {<br>        inputMint: 'So11111111111111111111111111111111111111112',<br>        outputMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',<br>        amount: '1000000000',<br>        slippage: 0.5<br>      };<br>      <br>      const response = await fetch(<code>${BASE_URL}/api/swap/quote</code>, {<br>        method: 'POST',<br>        headers: { 'Content-Type': 'application/json' },<br>        body: JSON.stringify(payload)<br>      });<br>      <br>      const data = await response.json();<br>      <br>      assert.strictEqual(response.status, 200);<br>      assert.strictEqual(data.inputMint, payload.inputMint);<br>      assert.strictEqual(data.outputMint, payload.outputMint);<br>      assert(data.outputAmount);<br>      assert(Array.isArray(data.route));<br>    });<br>    <br>    it('should handle invalid token pairs gracefully', async () => {<br>      const payload = {<br>        inputMint: 'invalid_mint_address',<br>        outputMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',<br>        amount: '1000000000',<br>        slippage: 0.5<br>      };<br>      <br>      const response = await fetch(<code>${BASE_URL}/api/swap/quote</code>, {<br>        method: 'POST',<br>        headers: { 'Content-Type': 'application/json' },<br>        body: JSON.stringify(payload)<br>      });<br>      <br>      assert.strictEqual(response.status, 400);<br>    });<br>  });<br>  <br>  describe('Performance', () => {<br>    it('should respond within acceptable time limits', async () => {<br>      const start = Date.now();<br>      const response = await fetch(<code>${BASE_URL}/api/health</code>);<br>      const duration = Date.now() - start;<br>      <br>      assert.strictEqual(response.status, 200);<br>      assert(duration < 5000, <code>Response took ${duration}ms, expected < 5000ms</code>);<br>    });<br>  });<br>  <br>});<br></code></pre></p><p><h3>Load Testing</h3><br><pre><code>bash<br><h1>Using Apache Bench (ab)</h1><br>ab -n 100 -c 10 https://filotmicroservice.replit.app/api/health</p><p><h1>Using curl for continuous monitoring</h1><br>watch -n 5 'curl -s https://filotmicroservice.replit.app/api/health | jq .status'<br></code></pre></p><p>---</p><p><h2>Production Best Practices</h2></p><p><h3>1. Connection Management</h3><br><pre><code>javascript<br>// Good: Reuse connections<br>class FilotApiClient {<br>  constructor() {<br>    this.baseUrl = 'https://filotmicroservice.replit.app';<br>    this.httpAgent = new http.Agent({ keepAlive: true });<br>  }<br>}</p><p>// Avoid: Creating new connections for each request<br></code></pre></p><p><h3>2. Caching Strategy</h3><br><pre><code>javascript<br>class CachedApiClient {<br>  constructor() {<br>    this.cache = new Map();<br>    this.cacheTimeout = 30000; // 30 seconds<br>  }<br>  <br>  async getPoolsWithCache() {<br>    const cacheKey = 'pools';<br>    const cached = this.cache.get(cacheKey);<br>    <br>    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {<br>      return cached.data;<br>    }<br>    <br>    const pools = await this.getPools();<br>    this.cache.set(cacheKey, {<br>      data: pools,<br>      timestamp: Date.now()<br>    });<br>    <br>    return pools;<br>  }<br>}<br></code></pre></p><p><h3>3. Error Recovery</h3><br><pre><code>python<br>import asyncio<br>from typing import Callable, Any</p><p>async def with_retry(<br>    func: Callable,<br>    max_retries: int = 3,<br>    base_delay: float = 1.0,<br>    max_delay: float = 60.0<br>) -> Any:<br>    """Execute function with exponential backoff retry"""<br>    for attempt in range(max_retries):<br>        try:<br>            return await func()<br>        except Exception as e:<br>            if attempt == max_retries - 1:<br>                raise<br>            <br>            delay = min(base_delay <em> (2 <strong> attempt), max_delay)<br>            print(f"Attempt {attempt + 1} failed: {e}. Retrying in {delay}s...")<br>            await asyncio.sleep(delay)<br></code></pre></p><p><h3>4. Monitoring & Alerting</h3><br><pre><code>javascript<br>class ApiMonitor {<br>  constructor() {<br>    this.metrics = {<br>      requests: 0,<br>      errors: 0,<br>      totalResponseTime: 0<br>    };<br>  }<br>  <br>  async monitoredRequest(url, options = {}) {<br>    const start = Date.now();<br>    this.metrics.requests++;<br>    <br>    try {<br>      const response = await fetch(url, options);<br>      <br>      if (!response.ok) {<br>        this.metrics.errors++;<br>        this.alertOnError(response.status, url);<br>      }<br>      <br>      return response;<br>    } catch (error) {<br>      this.metrics.errors++;<br>      this.alertOnError('NETWORK_ERROR', url);<br>      throw error;<br>    } finally {<br>      this.metrics.totalResponseTime += Date.now() - start;<br>    }<br>  }<br>  <br>  getErrorRate() {<br>    return this.metrics.requests > 0 <br>      ? this.metrics.errors / this.metrics.requests <br>      : 0;<br>  }<br>  <br>  getAverageResponseTime() {<br>    return this.metrics.requests > 0 <br>      ? this.metrics.totalResponseTime / this.metrics.requests <br>      : 0;<br>  }<br>  <br>  alertOnError(status, url) {<br>    if (this.getErrorRate() > 0.1) { // 10% error rate<br>      console.error(<code>High error rate detected: ${this.getErrorRate()}%</code>);<br>      // Implement alerting logic (email, Slack, etc.)<br>    }<br>  }<br>}<br></code></pre></p><p>---</p><p><h2>Troubleshooting</h2></p><p><h3>Common Issues</h3></p><p>#### 1. "Token not found" Error<br><pre><code>javascript<br>// Problem: Token mint address doesn't exist in database<br>// Solution: Check if token exists first<br>async function safeGetToken(mint) {<br>  try {<br>    const response = await fetch(<code>${BASE_URL}/api/tokens/${mint}</code>);<br>    if (response.status === 404) {<br>      console.log('Token not found in FiLot database');<br>      return null;<br>    }<br>    return await response.json();<br>  } catch (error) {<br>    console.error('Error fetching token:', error);<br>    return null;<br>  }<br>}<br></code></pre></p><p>#### 2. Swap Quote Failures<br><pre><code>javascript<br>// Problem: Invalid token pair or insufficient liquidity<br>// Solution: Validate inputs and handle gracefully<br>async function calculateSwapWithValidation(inputMint, outputMint, amount) {<br>  // Validate mint addresses<br>  if (!isValidMintAddress(inputMint) || !isValidMintAddress(outputMint)) {<br>    throw new Error('Invalid mint address format');<br>  }<br>  <br>  // Check if tokens exist<br>  const [inputToken, outputToken] = await Promise.all([<br>    safeGetToken(inputMint),<br>    safeGetToken(outputMint)<br>  ]);<br>  <br>  if (!inputToken || !outputToken) {<br>    throw new Error('One or both tokens not found');<br>  }<br>  <br>  try {<br>    return await getSwapQuote(inputMint, outputMint, amount);<br>  } catch (error) {<br>    if (error.message.includes('insufficient liquidity')) {<br>      throw new Error('Insufficient liquidity for this pair');<br>    }<br>    throw error;<br>  }<br>}</p><p>function isValidMintAddress(address) {<br>  return /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address);<br>}<br></code></pre></p><p>#### 3. Performance Issues<br><pre><code>javascript<br>// Problem: Slow response times<br>// Solution: Implement timeout and parallel requests<br>async function fetchWithTimeout(url, options = {}, timeoutMs = 10000) {<br>  const controller = new AbortController();<br>  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);<br>  <br>  try {<br>    const response = await fetch(url, {<br>      ...options,<br>      signal: controller.signal<br>    });<br>    return response;<br>  } finally {<br>    clearTimeout(timeoutId);<br>  }<br>}</p><p>// Parallel requests for better performance<br>async function fetchMultipleEndpoints() {<br>  const [health, pools, tokens] = await Promise.all([<br>    fetchWithTimeout(<code>${BASE_URL}/api/health</code>),<br>    fetchWithTimeout(<code>${BASE_URL}/api/pools</code>),<br>    fetchWithTimeout(<code>${BASE_URL}/api/tokens</code>)<br>  ]);<br>  <br>  return {<br>    health: await health.json(),<br>    pools: await pools.json(),<br>    tokens: await tokens.json()<br>  };<br>}<br></code></pre></p><p><h3>Debug Mode</h3><br><pre><code>javascript<br>class DebugApiClient {<br>  constructor(debug = false) {<br>    this.debug = debug;<br>    this.requestLog = [];<br>  }<br>  <br>  async request(url, options = {}) {<br>    const startTime = Date.now();<br>    <br>    if (this.debug) {<br>      console.log(<code>API Request: ${options.method || 'GET'} ${url}</code>);<br>      if (options.body) {<br>        console.log(<code>Request Body:</code>, JSON.parse(options.body));<br>      }<br>    }<br>    <br>    try {<br>      const response = await fetch(url, options);<br>      const duration = Date.now() - startTime;<br>      <br>      const logEntry = {<br>        url,<br>        method: options.method || 'GET',<br>        status: response.status,<br>        duration,<br>        timestamp: new Date().toISOString()<br>      };<br>      <br>      this.requestLog.push(logEntry);<br>      <br>      if (this.debug) {<br>        console.log(<code>API Response: ${response.status} (${duration}ms)</code>);<br>      }<br>      <br>      return response;<br>    } catch (error) {<br>      const duration = Date.now() - startTime;<br>      <br>      if (this.debug) {<br>        console.error(<code>API Error: ${error.message} (${duration}ms)</code>);<br>      }<br>      <br>      throw error;<br>    }<br>  }<br>  <br>  getRequestLog() {<br>    return this.requestLog;<br>  }<br>  <br>  clearLog() {<br>    this.requestLog = [];<br>  }<br>}</p><p>// Usage<br>const client = new DebugApiClient(true); // Enable debug mode<br></code></pre></p><p>---</p><p><h2>Support & Resources</h2></p><p><h3>API Status Page</h3><br>Monitor real-time API status: <code>https://filotmicroservice.replit.app/api/health</code></p><p><h3>Contact Information</h3><br>- </strong>Telegram:<strong> <a href="https://t.me/Fi_lotbot">@Fi_lotbot</a><br>- </strong>X (Twitter):<strong> <a href="https://x.com/crazyrichla">@crazyrichla</a><br>- </strong>Email:<strong> support@filot.io<br>- </strong>Location:<strong> Dubai International Financial Centre</p><p><h3>Additional Resources</h3><br>- </strong>Official Documentation:<strong> <code>https://filotmicroservice.replit.app/docs</code><br>- </strong>API Metrics:<strong> <code>https://filotmicroservice.replit.app/api/metrics</code><br>- </strong>Health Status:<strong> <code>https://filotmicroservice.replit.app/api/health</code></p><p>---</p><p><h2>License & Terms</h2></p><p>This API is provided free of charge for development and commercial use. By using this API, you agree to:</p><p>- Use the service responsibly and not abuse rate limits<br>- Not attempt to reverse engineer or compromise the service<br>- Acknowledge that this is a free service with no SLA guarantees<br>- Report any issues or suggestions to our support channels</p><p></strong>Disclaimer:</em><em> This API provides access to DeFi data and calculations. Users are responsible for validating all data before making financial decisions. FiLot is not responsible for any losses incurred from using this API.</p><p>---</p><p></em>Last updated: May 24, 2025<em><br></em>Version: 1.0.0*</p>
    </div>
    <div class="footer">
        <p>FiLotMicroservice v1.0.0 | Precision Investing API | Authentic Raydium SDK v2 Integration</p>
        <p>Generated on 5/24/2025</p>
        <p>Contact: support@filot.io | Telegram: @Fi_lotbot | X: @crazyrichla</p>
    </div>
</body>
</html>